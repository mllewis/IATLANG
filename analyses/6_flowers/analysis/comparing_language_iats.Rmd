---
title: Comparing language IATs
author: Molly Lewis 
date: "`r Sys.Date()`"
output: 
  html_document:
    code_folding: hide
    number_sections: no
    toc: yes
---
  
******

```{r setup, include = F}
rm(list = ls())

# load packages
library(knitr)
library(rmarkdown)
library(tidyverse)
library(knitr)
library(broom)
library(corrplot)

opts_chunk$set(echo = T, message = F, warning = F, 
               error = F, tidy = F, cache = F)
```

Read in four sets of effect sizes: career (hand translations), career (google translations), flowers (google translations), and weapons (google translations). 

We need to exclude some languages based on the mean proportion missing translations for each test .1 seems like a conservative cuttoff.

```{r}
ALPHA <- .1

TESTS <- c("career_google", "career_hand", "flowers_google", "career_behavioral_iat", "wps_index", "weapons_google")

```

```{r}
career_hand <- read.csv("/Users/mollylewis/Documents/research/Projects/IATLANG/writeup/cogsci2018/analysis/study2b/data/career_effect_sizes_hand_translations.csv", col.names = c("wiki_language_code", "test_id", "test_name", "es"),  header = F, fill = TRUE) %>%
  mutate(test_version = "career_hand")

career_google <- read.csv("/Users/mollylewis/Documents/research/Projects/IATLANG/writeup/cogsci2018/analysis/study2b/google_translate_and_names_analysis/data/career_effect_sizes_google_translations.csv", col.names = c("wiki_language_code", "test_id", "test_name", "es"),  header = F, fill = TRUE) %>%
  mutate(test_version = "career_google")

flowers_google <- read.csv("../data/flowers_effect_sizes_google.csv", 
                           col.names = c("wiki_language_code", "test_id", "test_name", "es"), header = F, fill = TRUE)  %>%
  mutate(test_version = "flowers_google")

weapons_google <- read.csv("../data/weapons_effect_sizes_google.csv", 
                           col.names = c("wiki_language_code", "test_id", "test_name", "es"), header = F, fill = TRUE) %>%
  mutate(test_version = "weapons_google")

```

### Distribution of proportion missing translations
```{r}
prop_missing_raw <- read_csv("../data/prop_google_translate_missing.csv")  %>%
  rowwise() %>%
  mutate(mean_prop_missing = mean(c(prop_missing_career, prop_missing_flowers, prop_missing_weapons))) %>%
  arrange(-mean_prop_missing)

ggplot(prop_missing_raw, aes(x = mean_prop_missing)) +
  geom_histogram() +
  theme_classic()
```

### Distribution of effect sizes by test (prop_missing < .1)
```{r, fig.width = 9}
PROP_MISSING_CUTOFF <- .1
prop_missing <- prop_missing_raw %>%
  filter(mean_prop_missing < PROP_MISSING_CUTOFF) 

all_es<- bind_rows(list(career_hand, career_google,flowers_google, weapons_google))  %>%
  select(-test_id, -test_name) %>%
  filter(wiki_language_code %in% prop_missing$language_code) %>%
  filter(wiki_language_code != "zh_yue")

ggplot(all_es, aes(x = es, fill = test_version)) +
  geom_density(alpha = .5) +
  theme_classic()
```

Weapons and flowers have much less spread that career.


### Correlations between effect sizes (prop_missing < .1)

```{r}
lang_codes <- read_csv("/Users/mollylewis/Documents/research/Projects/IATLANG/writeup/cogsci2018/analysis/study2b/data/language_names_to_wiki_codes.csv")

behavioral_wps <- read_csv("/Users/mollylewis/Documents/research/Projects/IATLANG/writeup/cogsci2018/analysis/all/all_measures_df.csv") %>%
   left_join(lang_codes) %>%
  group_by(wiki_language_code) %>%
  summarise(career_behavioral_iat =
              weighted.mean(es_behavioral_iat,
                            normalized_n, na.rm = T),
            wps_index = mean(wps_index)) 

```

```{r}
PROP_MISSING_CUTOFF <- .1

prop_missing <- prop_missing_raw %>%
  filter(mean_prop_missing < PROP_MISSING_CUTOFF) 

all_es_wide <- bind_rows(list(career_hand, career_google, flowers_google, weapons_google))  %>%
  select(-test_id, -test_name) %>%
  filter(wiki_language_code %in% prop_missing$language_code) %>%
  filter(wiki_language_code != "zh_yue") %>%
  spread(test_version, es) %>%
  left_join(behavioral_wps)

unique_pairs <- tidyr::crossing(TESTS ,TESTS) %>% 
  magrittr::set_colnames(c("test1", "test2")) %>%
  rowwise() %>%
  mutate(test1 = sort(c(test1, test2))[1],       # sort order of words for each row
         test2 = sort(c(test1, test2))[2]) %>%
  filter(test1 != test2) %>%                      # remove word combinations with itself
  unique()  

get_corr <- function(test1, test2, df){
  df %>%
    select(test1, test2) %>%
    do(tidy(cor.test(.[,1], .[,2]))) %>%
    mutate(test1 = test1, 
           test2 = test2)
}

map2_df(unique_pairs$test1, unique_pairs$test2, get_corr, all_es_wide)  %>%
  select(test1, test2, estimate, statistic, p.value, parameter) %>%
  mutate(sig = ifelse(p.value < ALPHA, "*", "")) %>%
  kable()
```

Note that correlations are highlighted at the `r ALPHA` level.
```{r}
corr_mat <- cor(all_es_wide[,c(-1)], 
                use = "pairwise.complete.obs")
p.mat <- cor.mtest(all_es_wide[,c(-1)], 
                  conf.level = .95,  
                  use = "pairwise.complete.obs")$p

cols = rev(colorRampPalette(c("red", "white", "blue"))(100))

corrplot(corr_mat, method = "color",  col = cols,
         type = "upper", order = "hclust", number.cex = .7,
         addCoef.col = "black", # Add coefficient of correlation
         tl.col = "black", tl.srt = 90, # Text label color and rotation
         # Combine with significance
         p.mat = p.mat, sig.level = ALPHA, insig = "blank", 
         # hide correlation coefficient on the principal diagonal
         diag = FALSE)

```

### Correlations between effect sizes (prop_missing < .2)
```{r}
PROP_MISSING_CUTOFF <- .2

prop_missing <- prop_missing_raw %>%
  filter(mean_prop_missing < PROP_MISSING_CUTOFF) 

all_es_wide <- bind_rows(list(career_hand, career_google,flowers_google, weapons_google))  %>%
  select(-test_id, -test_name) %>%
  filter(wiki_language_code %in% prop_missing$language_code) %>%
  filter(wiki_language_code != "zh_yue") %>%
  spread(test_version, es) %>%
  left_join(behavioral_wps)

 map2_df(unique_pairs$test1, unique_pairs$test2, get_corr, all_es_wide)  %>%
  select(test1, test2, estimate, statistic, p.value, parameter) %>%
    mutate(sig = ifelse(p.value < ALPHA, "*", "")) %>%
  kable()
 
```
 
```{r}
corr_mat <- cor(all_es_wide[,c(-1)], use = "pairwise.complete.obs")
p.mat <- cor.mtest(all_es_wide[,c(-1)], 
                  conf.level = .95,  
                  use = "pairwise.complete.obs")$p

corrplot(corr_mat, method = "color",  col = cols,
         type = "upper", order = "hclust", number.cex = .7,
         addCoef.col = "black", # Add coefficient of correlation
         tl.col = "black", tl.srt = 90, # Text label color and rotation
         # Combine with significance
         p.mat = p.mat, sig.level = ALPHA, insig = "blank", 
         # hide correlation coefficient on the principal diagonal
         diag = FALSE)

```
 
 
```{r, eval = F}

library(corrr)
library(corrplot)
correlate(all_es_wide[,-1], use = "pairwise.complete.obs") %>%
  rplot()

res1 <- cor.mtest(all_es_wide[,-1], 
                  conf.level = .95,  
                  use = "pairwise.complete.obs")



## specialized the insignificant value according to the significant level
corrplot(M, p.mat = res1$p, sig.level = .2)
corrplot.mixed(M, 
               lower.col = "black",
               number.cex = .7, 
               p.mat = res1$p, 
               sig.level = ALPHA)

corrplot.mixed(M, type = "upper", order = "hclust", 
         p.mat = res1$p, sig.level = 0.01)


```
